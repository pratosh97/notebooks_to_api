import json,fire,re,shutil,os
from typing import Dict, List
from pathlib import Path
import io
from create_api import choose_api

api_modules_subdir = 'exp_api_modules'
scripts_subdir = 'exports'
api_flow_file = 'api_flow.py'

def is_export(cell:Dict)->bool:
    ''' Checks if a cell marked with #export
        Arguments:
            cell: a notebook cell
        Returns:
            True if the cell is marked with #export
    '''
    if cell['cell_type'] != 'code': return False
    src = cell['source']
    if len(src) == 0 or len(src[0]) < 7: return False
    return re.match(r'^\s*#\s*export\s*$', src[0], re.IGNORECASE) is not None



def getSortedFiles(allFiles:bool or List or str)->List[str]:
    '''Returns all the notebok files sorted by name.
       Arguments:
        allFiles = True : returns all files
                    = '*_*.ipynb' : returns this pattern
                    = ['file1.ipynb','file2.ipynb'] : returns the list of files
       The sorting option is important to ensure that the notebok are executed in correct order.
    '''
    import glob
    ret = []
    if (allFiles==True): ret = glob.glob('*.ipynb') 
    elif isinstance(allFiles,List): ret = allFiles
    elif isinstance(allFiles,str): ret = glob.glob(allFiles)
    if 0==len(ret): 
        print('WARNING: No files found')
        return ret
    return ret



def notebook2script(fname:str=None, allFiles:bool or List or str=None):
    '''Finds cells starting with `#export` and puts them into a new module
       Arguments:
        fname: the name of the notebook file to parse
        allFiles: convert all files in the folder

       Eg: 
        notebook2script --allFiles=True   # Parse all files
        notebook2script --allFiles=nb*   # Parse all files starting with nb*
    '''
    # initial checks
    if not fname and not allFiles: 
        raise ValueError('atleast a filename must be provided')
    if fname and not isinstance(fname,str):
        raise TypeError(f'fname should be a string,but given {type(fname)}')
    if allFiles and not isinstance(allFiles,(bool,str,List)): 
        raise TypeError(f'allFiles should be a bool or a list or a string,but given {type(allFiles)}')
    if not allFiles: notebook2scriptSingle(fname)
    else:
        print('Begin...')
        [notebook2scriptSingle(f) for f in getSortedFiles(allFiles)]
        print('...End')



def notebook2scriptSingle(fname:str):    
    '''Finds cells starting with `#export` and puts them into a new module
       Arguments:
        fname: the name of the notebook file to parse
    '''
    fname = Path(fname)
    # script name same as the notebook name
    fname_out = f'{fname.stem}.py'
    main_dic = json.load(open(fname,'r',encoding="utf-8"))
    # checking the cells with #export tag
    code_cells = [c for c in main_dic['cells'] if is_export(c)]
    module = f'''
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: {fname.parent}/{fname.name}
'''
    for cell in code_cells: module += ''.join(cell['source'][1:]) + '\n\n'
    # remove trailing spaces
    module = re.sub(r' +$', '', module, flags=re.MULTILINE)
    output_path = f'{scripts_subdir}/{fname_out}'
    if not os.path.exists(scripts_subdir): os.mkdir(scripts_subdir)
    with io.open(output_path, "w", encoding="utf-8") as f:
        f.write(module[:-2])
    # check for the api_flow module which must have main() , load_model() functions
    '''if output_path == f'{scripts_subdir}/api_flow.py':
        from ..exports import api_flow
        if not hasattr(api_flow, 'main'):
            raise ValueError('api_flow.py has no `main` function, make sure it has a `def main` function')
        if not hasattr(api_flow, 'load_model'):
            raise ValueError('api_flow.py has no `load_model` function, make sure it has a `def load_model` function')'''
    print(f"Converted {fname} to {output_path}")



def structure_modules(mod_struct_path:str='notebooks_to_api/module_structure_config.json'):
    '''structuring the api modules
    ''' 
    api_folder_struct = json.load(open(mod_struct_path))
    if isinstance(api_folder_struct,Dict): 
        # each time it deletes the directory and recreates them
        if os.path.exists(api_modules_subdir): shutil.rmtree(api_modules_subdir, ignore_errors=True)
        os.mkdir(api_modules_subdir)
        # frist copies all the files from "exports" and then structures them
        for file in os.listdir('exports'): shutil.copy(scripts_subdir+'/'+file, api_modules_subdir+'/'+file)
        print('structring the api modules.......')
        for key,value in api_folder_struct.items():        
            os.mkdir(api_modules_subdir+'/'+key)
            print(f'{key} is being created')
            for name in value: shutil.move(api_modules_subdir+'/'+name, api_modules_subdir+'/'+key+'/'+name)
        # check if the api_flow.py is present in the api_modules_subdir
        if api_flow_file not in os.listdir(api_modules_subdir): 
            raise ValueError(f'{api_flow_file} is not found in {api_modules_subdir}, make sure the file is inside the directory')
        print('api modules structured !!!')
    else: 
        raise TypeError(f'api_folder_struct should be a dictionary,but given {type(api_folder_struct)}')



def update(fname:str=None, allFiles:bool or List or str=None):
    '''update the api modules
       Arguments:
        fname: the name of the notebook file updated
    '''
    print('updating the api modules.......')
    if fname or allFiles: notebook2script(fname,allFiles)
    structure_modules()
    choose_api()
    print('api modules updated !!!')



if __name__ == '__main__': fire.Fire({'notebook2script': notebook2script, 'structure': structure_modules, 'update':update})

